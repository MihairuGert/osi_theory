## Теоретические вопросы
1. Что такое fork(2) и что он делает? [[Syscalls clone(), fork(), vfork()]] 
2. Что такое clone(2) и что он делает? [[Syscalls clone(), fork(), vfork()]]
3. Состояния процесса. Состояние zombie и зачем оно нужно? [[Process state]]
4. Как получить код возврата процесса и что этот код из себя представляет? [[Exit code and SIGCHLD]]
5. Что находится в proc, proc/stat? [[proc procstat]]
6. Процесс init, зачем он нужен. [[init process]]
7. Что происходит с дочерними процессами, если родительский умирает? [[init process]]
8. Сигнал SIGCHLD. Зачем он нужен и в каких случаях приходит? [[Exit code and SIGCHLD]] 
# Процессы*
\* *an instance of a program in execution.*

О них можно думать, как о совокупности структур данных, полностью описывающих выполнение программы.

С точки зрения ядра, цель процесса - действовать как сущность, которой выделяются ресурсы (CPU time, память и тд.). Когда процесс рождается, он практически идентичен родителю. Он получает логическую копию родительского адресного пространства и исполняет родительский код, начиная с инструкции сразу после сискола создания процесса. Несмотря на это, родитель и ребенок имеют разные копии данных (стека и кучи).

Современные Unix ядра поддерживают многопоточные приложения. В таких системах процесс состоит из нескольких пользовательских потоков (или просто потоков), каждый представляющий поток исполнения процесса. Но в таком подходе есть изьян: для ядра многопоточное приложение лишь один процесс, и если какой-то поток "внутри" решит вызвать блокирующий сискол (например, для ожидания ввода данных пользователем), то он заблокирует и все остальные потоки.

Для решения этой проблемы в линуксе применяются легковесные (*lightweight*) процессы, прикрепляемые к каждому потоку. 

**Дескриптор процесса**

Чтобы управлять процессами, ядру необходимо знать о них информацию. Для этого существуют дескрипторы процессов - типа task_struct (иногда task_t), содержащие всю информацию о процессе. Такие структуры очень сложны.
![[Pasted image 20250421212029.png]]
Рассмотрим некоторые поля.

[[Process state]]

Как общее правило, каждый процесс должен иметь свой собственный дескриптор. Строгое соотношение один к одному между процессом и его дескриптором позволяет определять ядру процессы. С другой стороны в Unix-подобных системах есть возможность определять процессы по их PID (Process ID), который хранится в pid field в дескрипторе. Линукс для каждого процесса определяет свой PID. (Однако, потоки в одной группе имеют общий PID, который соответствует первому легковесному процессу в группе и хранится в tgid. getpid() возвращает именно значение этого поля, а не pid. Всё это требует стандарт *POSIX 1003.1c*. Важно сказать, что получить истинный pid можно).  

**Взаимоотношения между процессами**

Процессы созданные программой имеют отношения родитель-ребенок. Когда процесс создает многих детей, то дети имеют отношение siblings (братьев и сестер). Отношения можно увидеть в следующей таблице:
![[Pasted image 20250421220801.png]]
**Замечание:** Процессы 0 и 1 создаются ядром. Процесс 1 (init) является прародителем (*ancestor*) всех процессов.

Однако родитель-ребенок не единственный способ взаимодействий. Процесс может быть лидером группы процессов, потоков или трассировать другие процессы. 
![[Pasted image 20250421221342.png]]
![[Pasted image 20250421221351.png]]

Иногда ядру может понадобиться получить указатель на дескриптор по PID, например для kill(). Для этого используются 4 хэш-таблицы.
![[Pasted image 20250421222056.png]]
![[Pasted image 20250421222700.png]]

**Организация процессов.**

Списки выполнения группируют все процессы в состояние TASK_RUNNING. В других же состояниях обращение другое. Процессы TASK_STOPPED, EXIT_ZOMBIE, EXIT_DEAD не собираются в отдельные особенные списки. Процессы TASK_INTERRUPTIBLE или TASK_UNINTERRUPTIBLE подразделяются на множественные классы, каждый из которых отвечает за определенное событие. 

Существуют очереди ожидания (*wait queues*), которые используются для обеспечения прерывания, синхронизации процессов и тайминга. Такие очереди реализуют условное ожидание событий: процесс, желающий подождать какое-либо событие добавляет себя в нужную очередь и отдает контроль (идет спать). Они реализованы как двусвязные списки, чьи элементы имеют указатель на дескриптор процессов. Всего есть 2 типа спящих процессов: exclusive и nonexclusive. Первые выборочно будятся ядром, а вторые все.  

**Создание процессов.**

Старые unix-системы обращались со всеми процессами одинаково: ресурсы родителя копировались ребенку, что делало создание процессов медленным и неэффективным, потому что требовалось скопировать всё адресное пространство родителя. Ребенку редко нужны эти ресурсы, поэтому во многих случаях, сразу делали execve() и чистили всё так тщательно скопированное адресное пространство. 

Современные ядра решают эту проблему тремя способами:
1) *Copy On Write* техника позволяет обоим родителю и ребенку читать одну и ту же физическую страницу памяти. Если один из них пытается записать в физическую страницу, то ядро копирует содержимое в новую физическую страницу, привязанную к записывающему процессу. 
2) *Lightweight* процессы позволяет обоим родителю и ребенку разделять многие структуры данных, например таблицу страниц, открытых файлов. 
3) *vfork()* сискол создает процесс разделяющий адресное пространство родителя. Чтобы предотвратить перезапись данных ребенком, исполнение родителя прерывается до того, как ребенок завершил работу или начал исполнять новую программу.

**Сисколы clone(), fork(), vfork().**

Используя функцию **clone()**, можно создать легковесные процессы в Linux. 
Её некоторые параметры:
***fn*** Указывает функцию для исполнения новым процессом. Когда функция завершается, завершается и ребенок. Функция возвращает целое число, которое представляет код выхода ребенка.
***arg*** Указывает на данные, передаваемые функции fn()

Сискол **fork()**, реализован линуксом как **clone()**, с установленными флагами SIGCHLD и всеми выключенными флагами clone(). *child_stack* указывает на текущий родительский указатель на стек (*stack pointer*). Поэтому родитель и ребенок временно делят общий *User Mode* стек. Используется механизм Copy On Write. 

