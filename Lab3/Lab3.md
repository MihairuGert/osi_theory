## Теоретические вопросы
1. Что такое fork(2) и что он делает?
2. Что такое clone(2) и что он делает?
3. Состояния процесса. Состояние zombie и зачем оно нужно? [[Process state]]
4. Как получить код возврата процесса и что этот код из себя представляет?
5. Что находится в proc, proc/stat?
6. Процесс init, зачем он нужен. [[init process]]
7. Что происходит с дочерними процессами, если родительский умирает? [[init process]]
8. Сигнал SIGCHLD. Зачем он нужен и в каких случаях приходит?
# Процессы*
\* *an instance of a program in execution.*

О них можно думать, как о совокупности структур данных, полностью описывающих выполнение программы.

С точки зрения ядра, цель процесса - действовать как сущность, которой выделяются ресурсы (CPU time, память и тд.). Когда процесс рождается, он практически идентичен родителю. Он получает логическую копию родительского адресного пространства и исполняет родительский код, начиная с инструкции сразу после сискола создания процесса. Несмотря на это, родитель и ребенок имеют разные копии данных (стека и кучи).

Современные Unix ядра поддерживают многопоточные приложения. В таких системах процесс состоит из нескольких пользовательских потоков (или просто потоков), каждый представляющий поток исполнения процесса. Но в таком подходе есть изьян: для ядра многопоточное приложение лишь один процесс, и если какой-то поток "внутри" решит вызвать блокирующий сискол (например, для ожидания ввода данных пользователем), то он заблокирует и все остальные потоки.

Для решения этой проблемы в линуксе применяются легковесные (*lightweight*) процессы, прикрепляемые к каждому потоку. 

**Дескриптор процесса**

Чтобы управлять процессами, ядру необходимо знать о них информацию. Для этого существуют дескрипторы процессов - типа task_struct (иногда task_t), содержащие всю информацию о процессе. Такие структуры очень сложны.
![[Pasted image 20250421212029.png]]
Рассмотрим некоторые поля.

[[Process state]]

Как общее правило, каждый процесс должен иметь свой собственный дескриптор. Строгое соотношение один к одному между процессом и его дескриптором позволяет определять ядру процессы. С другой стороны в Unix-подобных системах есть возможность определять процессы по их PID (Process ID), который хранится в pid field в дескрипторе. Линукс для каждого процесса определяет свой PID. (Однако, потоки в одной группе имеют общий PID, который соответствует первому легковесному процессу в группе и хранится в tgid. getpid() возвращает именно значение этого поля, а не pid. Всё это требует стандарт *POSIX 1003.1c*. Важно сказать, что получить истинный pid можно).  

**Взаимоотношения между процессами**

Процессы созданные программой имеют отношения родитель-ребенок. Когда процесс создает многих детей, то дети имеют отношение siblings (братьев и сестер). Отношения можно увидеть в следующей таблице:
![[Pasted image 20250421220801.png]]
**Замечание:** Процессы 0 и 1 создаются ядром. Процесс 1 (init) является прародителем (*ancestor*) всех процессов.

Однако родитель-ребенок не единственный способ взаимодействий. Процесс может быть лидером группы процессов, потоков или трассировать другие процессы. 
![[Pasted image 20250421221342.png]]
![[Pasted image 20250421221351.png]]

Иногда ядру может понадобиться получить указатель на дескриптор по PID, например для kill(). Для этого используются 4 хэш-таблицы.
![[Pasted image 20250421222056.png]]
![[Pasted image 20250421222700.png]]

**Организация процессов.**