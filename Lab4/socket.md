**Сокет** - это абстракция сетевого взаимодействия в операционной системе Linux. Каждому сокету соответствует пара IP-адрес + номер порта. Это стандартное определение, к которому привыкли все, спасибо вики. Хотя нет, вот здесь лучше описано. Поскольку сокет является только лишь абстракцией, то связка IP-адрес + номер порта - это уже имплементация в ОС. Верное название этой имплементации - "Интернет сокет". Абстракция используется для того, чтобы операционная система могла работать с любым типом канала передачи данных. Именно поэтому в ОС Linux Интернет сокет - это дескриптор, с которым система работает как с файлом. Типов сокетов, конечно же, намного больше. В ядре ОС Linux сокеты представлены тремя основными структурами:

struct socket - представление сокета BSD, того вида сокета, который стал основой для современных "Интернет сокетов" **(Беркли)**
struct sock - собственная оболочка, которая в Linux называется "INET socket";
struct sk_buff - "хранилище" данных, которые передает или получает сокет;

Как видно по исходным кодам, все структуры достаточно объемны. Работа с ними возможна при использовании языка программирования или специальных оберток и написания приложения. Для эффективного управления этими структурами нужно знать, какие типы операций над сокетами существуют и когда их применять. Для сокетов существует набор стандартных действий:

socket - создание сокета;
bind - действие используется на стороне сервера. В стандартных терминах - это открытие порта на прослушивание, используя указанный интерфейс;
listen - используется для перевода сокета в прослушивающее состояние. Применяется к серверному сокету;
connect - используется для инициализации соединения;
accept - используется сервером, создает новое соединение для клиента;
send/recv - используется для работы с отправкой/приемом данных;
close - разрыв соединения, уничтожение сокета.

# Сокет Беркли
*ещё называемый BSD-сокетом*

Стандартный программный интерфейс (api) для работы с сетевыми коммуникациями.  Особенный тем, что:
- Работает с **TCP, UDP, Unix-сокетами** и другими протоколами.
- Подходит для **локального (IPC) и сетевого взаимодействия**.
- Один и тот же код (с небольшими правками) работает в **Linux, Windows, macOS**.
- Можно использовать в **блокирующем и неблокирующем** режимах.
- Поддержка **мультиплексирования** (`select`, `poll`, `epoll`, `kqueue`).

**Создание сокета:**
*int socket(int domain, int type, int protocol);*
- **`domain`** (семейство адресов):
    - `AF_INET` — IPv4, `AF_INET6` — IPv6, `AF_UNIX` — локальные сокеты (IPC).
- **`type`** (тип сокета):
    - `SOCK_STREAM` — TCP (надёжный, с установкой соединения).
    - `SOCK_DGRAM` — UDP (ненадёжный, датаграммы).
    - **`SOCK_SEQPACKET`** — Надёжная передача **сообщений с границами** (аналог TCP, но с сохранением структуры данных).
    - `SOCK_RAW`: — Позволяет работать с **сырыми пакетами** (например, для своего IP-стека).
- **`protocol`** (обычно `0` — автоматический выбор).

**Привязка к адресу:**
*int bind(int sockfd, const struct sockaddr addr, socklen_t addrlen);*
- **`addr`** — структура с адресом (например, `struct sockaddr_in` для IPv4).
- **`addrlen`** — размер структуры.

``` c
struct sockaddr_in addr = {
    .sin_family = AF_INET,
    .sin_port = htons(8080),          // Порт 8080
    .sin_addr.s_addr = INADDR_ANY     // Слушать все интерфейсы
};
bind(sock, (struct sockaddr*)&addr, sizeof(addr));
```

**Прослушивание подключений:**
*int listen(int sockfd, int backlog);*
- **`backlog`** — максимальная длина очереди ожидающих подключений.

**Принятие подключения:**
*int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);*
- Возвращает **новый сокет** для общения с клиентом.
- **`addr`** — заполняется адресом клиента (можно передать `NULL`).

**Установка соединения:**
*int connect(int sockfd, const struct sockaddr addr, socklen_t addrlen);*

``` c
struct sockaddr_in server_addr = {
    .sin_family = AF_INET,
    .sin_port = htons(8080),
    .sin_addr.s_addr = inet_addr("192.168.1.1")  // IP сервера
};
connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr));
```

**Передача данных:** (*send/recv*)
*ssize_t send(int sockfd, const void buf, size_t len, int flags);*
*ssize_t recv(int sockfd, void *buf, size_t len, int flags);*
- **`flags`**:
    - `MSG_WAITALL` — ждать полного заполнения буфера.
    - `MSG_DONTWAIT` — неблокирующий режим.

``` c
char buf[1024];
recv(client_sock, buf, sizeof(buf), 0);  // Чтение данных
send(client_sock, "Hello", 6, 0);       // Отправка данных
```

# Процесс установления связи доменных сокетов.

**Unix-сокеты (AF_UNIX) — локальное IPC**

**Сервер:**
``` c
int server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
struct sockaddr_un addr = {
    .sun_family = AF_UNIX,
    .sun_path = "/tmp/mysocket"  // Файл сокета
};
bind(sock, (struct sockaddr*)&addr, sizeof(addr));
listen(server_fd, 5);  // Очередь до 5 соединений
int client_fd = accept(server_fd, NULL, NULL);

// Сервер отправляет данные
send(client_fd, "Hello from server!", 18, 0);

close(client_fd);  // Закрываем соединение
close(server_fd);  // Закрываем серверный сокет
unlink("/tmp/mysocket");  // Удаляем файл сокета (опционально)
```

**Клиент:**
```c
int sock = socket(AF_UNIX, SOCK_STREAM, 0);
struct sockaddr_un addr = {
    .sun_family = AF_UNIX,
    .sun_path = "/tmp/mysocket"  // Тот же путь, что у сервера
};
connect(sock, (struct sockaddr*)&addr, sizeof(addr));

// Клиент принимает данные
char buf[100];
recv(sock, buf, sizeof(buf), 0);
printf("Received: %s\n", buf);  // "Hello from server!"

close(sock);
```

# В чём различие потоковой и датаграммной передачи данных? 

Первый TCP-подобный, второй - UDP
# Блокирующие и неблокирующие сокеты в чём различие? 

В блокирующих , когда процесс вызывает операцию (например, `recv()`, `accept()`, `send()`), он **блокируется** (приостанавливается), пока операция не завершится. Поток/процесс не может выполнять другие задачи в это время.

В неблокирующих, операции **не блокируют** поток. Если данные не готовы, функция сразу возвращает управление с ошибкой `EWOULDBLOCK`/`EAGAIN`. Требует использования **циклов опроса** (`select`, `poll`, `epoll`) или **асинхронных механизмов**.

# Мультиплексор. Что это и зачем используется?

**Мультиплексор** — это механизм, позволяющий одному потоку или процессу эффективно отслеживать и управлять множеством операций ввода-вывода (например, сокетами, файлами, пайпами) **без блокировки**

Мультиплексор (`select`, `poll`, `epoll`, `kqueue`) позволяет **одному потоку** обрабатывать **сотни тысяч соединений**, потому что ядро ОС само уведомляет приложение о готовности дескрипторов и нет активного опроса (spin-loop), который нагружает CPU.

Принцип работы прост: приложение регистрирует файловые дескрипторы** (сокеты, пайпы и т. д.) в мультиплексоре. **Мультиплексор блокируется** до тех пор, пока хотя бы один дескриптор не станет готовым. **Ядро возвращает список готовых дескрипторов**, и приложение обрабатывает их **без холостого ожидания**.


https://www.kernel.org/doc/html/latest/networking/kcm.html