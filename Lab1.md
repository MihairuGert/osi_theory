Секция – это наименьший неделимый структурный элемент в ELF файле. При загрузке в память, секции объединяются в сегменты. Сегменты – это наименьшие неделимые части ELF файла, которые могут быть отображены в память загрузчиком (ld-linux.so.2).
### **1. Из каких этапов состоит компиляция (используйте флаги компилятора и посмотрите промежуточные результаты)?**

**1) Препроцессинг.** Можно вызвать следующим образом:
```
g++ -E driver.cpp -o driver.ii
```
**2) Компиляция.** Преобразование кода с прошлого шага в ассемблерный код. Данный код всё ещё читаем.
```
$ g++ -S driver.ii -o driver.s
```
**3) Ассемблирование.** Ассемблер преобразует полученный код в машинный код, сохраняя его в объектный файл. 
**Объектный файл** — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется _объектным кодом_.
Далее возможно сохранение данного объектного кода в _статические библиотеки_ для того, чтобы не компилировать данный код снова.
```
$ as driver.s -o driver.o
```
**4) Компоновка (Линковка).** **Компоновщик (линкер)** связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем. Для того, чтобы понять как происходит связка, следует рассказать о _таблице символов_.
**Таблица символов** — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на данные и процедуры в других объектных файлах.  
Именно с помощью таблицы символов и хранящихся в них ссылок линкер будет способен в дальнейшем построить связи между данными среди множества других объектных файлов и создать единый исполняемый файл из них.
```
$ g++ driver.o -o driver // также тут можно добавить и другие объектные файлы и библиотеки
```
**5) Загрузка.** Загружаем программу в память. Возможна подгрузка динамических библиотек.
```
$ ./driver 
```

![[Pasted image 20250210195458.png]]

### **2. Что такое `elf` файл и какие его типы бывают?**

ELF — это сокращение от Executable and Linkable Format (формат исполняемых и связываемых файлов) и определяет структуру бинарных файлов, библиотек, и файлов ядра (core files). Спецификация формата позволяет операционной системе корректно интерпретировать содержащиеся в файле машинные команды. Файл ELF, как правило, является выходным файлом компилятора или линкера и имеет двоичный формат. С помощью подходящих инструментов он может быть проанализирован и изучен.

![[Pasted image 20250210192446.png]]
Заголовок ELF начинается с «магического числа». Это «магическое число» даёт информацию о файле. Первые 4 байта определяют, что это ELF-файл (45=E,4c=L,46=F, перед ними стоит значение 7f).

После объявления типа ELF, следует поле класса. Это значение означает архитектуру, для которой предназначен файл. Оно может равняться 01 (32-битная архитектура) или 02 (64-битная). Здесь мы видим 02, что переводится командой readelf как файл ELF64, то есть, другими словами, этот файл использует 64-битную архитектуру. 

Далее идёт поле «данные», имеющее два варианта: 01 — LSB (Least Significant Bit), также известное как little-endian, либо 02 — MSB (Most Significant Bit, big-endian). Эти значения помогают интерпретировать остальные объекты в файле. В нашем случае используется LSB, так как процессор имеет архитектуру AMD64.

Затем следует ещё одно магической значение «01», представляющее собой номер версии. В настоящее время имеется только версия 01, поэтому это число не означает ничего интересного.

Каждая операционная система имеет свой способ вызова функций, они имеют много общего, но, вдобавок, каждая система, имеет небольшие различия. Порядок вызова функции определяется «двоичным интерфейсом приложения» Application Binary Interface (ABI). Поля OS/ABI описывают, какой ABI используется, и его версию. В нашем случае, значение равно 00, это означает, что специфические расширения не используются. В выходных данных это показано как System V.

Поле типа указывает, для чего предназначен файл. Вот несколько часто встречающихся типов файлов.  
CORE (значение 4)  
DYN (Shared object file), библиотека (значение 3)  
EXEC (Executable file), исполняемый файл (значение 2)  
REL (Relocatable file), файл до линковки (значение 1)

Хотя некоторые поля могут быть просмотрены через readelf, их на самом деле больше. Например, можно узнать, для какого процессора предназначен файл. Используем hexdump, чтобы увидеть полный заголовок ELF и все значения.
`hexdump -C -n 64 /bin/ps`

Помимо заголовка, файлы ELF состоят из трёх частей.  
- Программные заголовки или сегменты
- Заголовки секций или секции
- Данные
Перед тем, как мы погрузимся в эти заголовки, *будет нелишним узнать, что файл ELF имеет два различных «вида». Один из них предназначен для линкера и разрешает исполнение кода (сегменты). Другой предназначен для команд и данных (секции).* В зависимости от цели, используется соответствующий тип заголовка. Начнём с заголовка программы, который находится в исполняемых файлах ELF.
Файл ELF состоит из нуля или более сегментов, и описывает, как создать процесс, образ памяти для исполнения в рантайме. Когда ядро видит эти сегменты, оно размещает их в виртуальном адресном пространстве, используя системный вызов mmap(2). Другими словами, конвертирует заранее подготовленные инструкции в образ в памяти. Если ELF-файл является обычным бинарником, он требует эти программные заголовки, иначе он просто не будет работать. Эти заголовки используются, вместе с соответствующими структурами данных, для формирования процесса. Для разделяемых библиотек (shared libraries) процесс похож.
![[Pasted image 20250210194843.png]]

PHDR
Заголовок PHDR (Program HeaDeR) определеяет расположение и размер таблицы заголовков программы и
связанные метаданные.

INTERP
Заголовок INTERP хранит путь к файлу интерпретатора, который должен запускаться, чтобы затем в свою очередь запустить программу. Почти во всех случаях эта программа будет файлом загрузчика операционной системы. Использование внешнего загрузчика необходимо, если программа использует динамически подключаемые библиотеки. Внешний загрузчик управляет глобальной таблицей символов программы, обрабатывает соединение двоичных файлов и в конце обращается к точке входа программы. Заголовок INTERP имеет отношение только к исполняемым файлам; для разделяемых библиотек, загружаемых либо во время начальной загрузки программы, либо динамически во время выполнения программы, это значение игнорируется.

LOAD
Заголовки LOAD сообщают операционной системе и загрузчику, как максимально эффективно загрузить данные программы в память. Каждый заголовок LOAD указывает загрузчику создать область памяти с заданным размером, правами доступа и критериями выравнивания, а также сообщает загрузчику, какие байты в файле следует поместить в эту область. 

DYNAMIC
Заголовок DYNAMIC используется загрузчиком для динамического связывания программ с общми библиотеками, которые используются в этих программах.

NOTE
Заголовок NOTE используется для хранения информации, специфичной для производителя программы. Этот раздел по сути представляет словарь, где ключами выступают строки-названия метаданных, а их значениями - последовательности байтов.

TLS
Заголовок TLS ("Thread-Local Storage") определяет таблицу записей TLS, в которых хранится информация о локальных переменных потока, используемых программой.

GNU_EH_FRAME
Это сортированная очередь, используемая компилятором GCC. В ней хранятся обработчики исключений. Если что-то пошло не так, они используются для того, чтобы корректно обработать ситуацию. Также определяет расположение в памяти таблиц очистки стека для программы. Таблицы очистки стека используются как отладчиками, так и функциями C++ для обработки исключений при использовании оператора `throw` или конструкции `try..catch`.

GNU_STACK
Этот заголовок используется для сохранения информации о стеке. Интересная особенность состоит в том, что стек не должен быть исполняемым, так как это может повлечь за собой уязвимости безопасности. Если сегмент GNU_STACK отсутствует, используется исполняемый стек.

GNU_RELRO
Заголовок GNU_RELRO (RELRO - Relocation Read-Only) указывает загрузчику после загрузки программы (но до того, как она начнет выполняться) пометить определенные критические области двоичного файла программы как доступные только для чтения. Что позволяет предотвратить возможную перезапись и внедрение вредоносного кода. В частности, этот заголовок используется для защиты глобальной таблицы смещений (Global Offset Table или кратко GOT), а также таблиц инициализации и финализации, которые содержат указатели на функции, запускаемые программой до запуска основной функции программы и для выхода.
Здесь мы увидим, что RELRO запрашивает загрузчик пометить разделы .tdata .init_array .fini_array .data.rel.ro и .got бинарного файла как доступные только для чтения перед запуском программы, то есть защитить данные TLS (.tdata), инициализаторы программы (.init_array, деструкторы (.fini_array) и глобальную таблицу смещений (.got).

### Итог
Файлы ELF предназначены для исполнения и линковки. В зависимости от назначения, они содержат необходимые сегменты и секции. Ядро ОС просматривает сегменты и отображает их в память (используя mmap). Секции просматриваются линкером, который создаёт исполняемый файл или разделяемый объект.  
  
Файлы ELF очень гибкие и поддерживаются различные типы CPU, машинные архитектуры, и операционные системы. Также он расширяемый, каждый файл сконструирован по-разному, в зависимости от требуемых частей. Путём использования правильных инструментов, вы сможете разобраться с назначением файла, и изучать содержимое бинарных файлов. Можно просмотреть функции и строки, содержащиеся в файле. Хорошее начало для тех, кто исследует вредоносные программы, или понять, почему процесс ведёт себя (или не ведёт) определённым образом.
### 3. Используйте `readelf`. Посмотрите основные секции `elf` файла и их назначение.
Очевидно после прочтения 2.
### 4. Статические и динамические библиотеки. Чем отличаются `relocatable` и `shared object` файлы?
